<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于自动生成java restful api文档的探索之smart-doc]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90java%20restful%20api%E6%96%87%E6%A1%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B9%8Bsmart-doc%2F</url>
    <content type="text"><![CDATA[前言谁说生成api文档就必须要定义注解？谁说生成接口请求和返回示例必须要在线？用代码去探路，不断尝试更多文档交付的可能性。如果代码有生命，为什么不换种方式和它对话！ 一、背景​ 在当今各种盛行的前后端分离、restful service开发过程中，接口文档是必不可少的。对于前后端分离的开发中，后端开发需要将接口写好后需要告诉前端工程师接口的请求参数、响应示例等重要信息，而对于对外暴露的restful接口服务，我们提供接口也是需要具备相同的接口文档的。 ​ 但是对于后端工程师来讲，写接口文档将变成一个很大的工作量，虽然现在有apidoc、swagger这样的主流接口文档生成工具，但是如果实际用过，会发现这些工具不能满足实际需求，这里拿swagger为例，这个工具最大的优点能是提供在线的api文档，但是它天生就有很强的代码侵入性，要得到一个基本满足需求的api接口文档，必须在代码中使用swagger自定义的注解。这其实给开发人员增加学习成本和工作量，并且就算你使用大量的注解，有许多接口还是无法满足。因此不得不去做一次接口文档工具重新启航探索，smart-doc应允而生，用代码去探路，消除繁杂的注解，发现天下没有难写接口文档。 二、smart-doc简介​ smart-doc是基于java开发用于解决java web restful接口文档书写难和生成难的问题，当然api-doc也是一款零注解完全基于源代码接口定义，使用java标准注释生成接口文档的工具。并且smart-doc代码也是完全开源的。目前生成的文档格式为markdown。 ​ smart-doc的码云仓库链接 ​ github仓库地址链接 三、功能特性 零注解、零学习成本、只需要写标准java注释。 基于源代码接口定义自动推导 支持springmvc、springboot 目前支持javabean上定义的部分fastjson和jackson注解 支持javabean上基于jsr303参数检验判断参数是否为必须 对json请求参数的接口能够自动生成模拟json参数 对一些常用字段定义能够生成有效的模拟值 支持生成json返回值示例 支持从项目外部加载源代码来生成字段注释 一款代码注解检测工具，明眼leader都知道接口文档直接反馈出注释情况 四、快速上手​ 1.导入smart-doc工具的依赖包 123456&lt;dependency&gt; &lt;groupId&gt;com.github.shalousun&lt;/groupId&gt; &lt;artifactId&gt;smart-doc&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ​ 2.编写一个单元测试类 ​ 妈妈再也不用担心我不会用了，So easy! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Description: * ApiDoc测试 * * @author yu 2018/06/11. */public class ApiDocTest &#123; /** * 简单型接口，不需要指定请求头，并且项目是maven的. * */ @Test public void testBuilderControllersApiSimple()&#123; //将生成的文档输出到d:\md目录下，严格模式下api-doc会检测Controller的接口注释 ApiDocBuilder.builderControllersApi(&quot;d:\\md&quot;,true); &#125; /** * 包括设置请求头，缺失注释的字段批量在文档生成期使用定义好的注释 */ @Test public void testBuilderControllersApi() &#123; ApiConfig config = new ApiConfig(); config.setStrict(true); config.setAllInOne(true);//true则将所有接口合并到一个AllInOne中markdown中，错误码合并到最后 config.setOutPath(&quot;d:\\md&quot;); // @since 1.2,如果不配置该选项，则默认匹配全部的controller, // 如果需要配置有多个controller可以使用逗号隔开 config.setPackageFilters(&quot;com.power.doc.controller.app&quot;); //默认是src/main/java,maven项目可以不写 config.setSourcePaths( SourcePath.path().setDesc(&quot;本项目代码&quot;).setPath(&quot;src/test/java&quot;), SourcePath.path().setPath(&quot;E:\\Test\\Mybatis-PageHelper-master\\src\\main\\java&quot;), SourcePath.path().setDesc(&quot;加载项目外代码&quot;).setPath(&quot;E:\\ApplicationPower\\ApplicationPower\\Common-util\\src\\main\\java&quot;) ); //设置请求头，如果没有请求头，可以不用设置 config.setRequestHeaders( ApiReqHeader.header().setName(&quot;access_token&quot;).setType(&quot;string&quot;).setDesc(&quot;Basic auth credentials&quot;), ApiReqHeader.header().setName(&quot;user_uuid&quot;).setType(&quot;string&quot;).setDesc(&quot;User Uuid key&quot;) ); //对于外部jar的类，api-doc目前无法自动获取注释， //如果有这种场景，则自己添加字段和注释，api-doc后期遇到同名字段则直接给相应字段加注释 config.setCustomResponseFields( CustomRespField.field().setName(&quot;success&quot;).setDesc(&quot;成功返回true,失败返回false&quot;), CustomRespField.field().setName(&quot;message&quot;).setDesc(&quot;接口响应信息&quot;), CustomRespField.field().setName(&quot;data&quot;).setDesc(&quot;接口响应数据&quot;), CustomRespField.field().setName(&quot;code&quot;).setValue(&quot;00000&quot;).setDesc(&quot;响应代码&quot;) ); //设置项目错误码列表，设置自动生成错误列表 List&lt;ApiErrorCode&gt; errorCodeList = new ArrayList&lt;&gt;(); for(ErrorCodeEnum codeEnum:ErrorCodeEnum.values())&#123; ApiErrorCode errorCode = new ApiErrorCode(); errorCode.setValue(codeEnum.getValue()).setDesc(codeEnum.getDesc()); errorCodeList.add(errorCode); &#125; //不是必须 config.setErrorCodes(errorCodeList); ApiDocBuilder.builderControllersApi(config); &#125;&#125;]]></content>
      <tags>
        <tag>java api 文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始构建你的api网关--Spring Cloud Gateway网关实战及原理解析]]></title>
    <url>%2F2019%2F08%2F16%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84api%E7%BD%91%E5%85%B3--Spring%20Cloud%20Gateway%E7%BD%91%E5%85%B3%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言参考文章： https://www.cnblogs.com/davidwang456/p/10411451.html 路由 Route（路由）：这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配。 Predicate（断言）：这是一个 Java 8 的 Predicate。输入类型是一个 ServerWebExchange。我们可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。 Filter（过滤器）：这是org.springframework.cloud.gateway.filter.GatewayFilter的实例，我们可以使用它修改请求和响应。 实战新建一个标准的 Spring Boot 工程，命名为 gateway，然后在 pom.xml 中引入以下依赖坐标 123456789101112131415161718&lt;!--Eureka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Gateway 路由--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 复制application.yml 配置文件内容如下 12345678910111213141516171819202122232425262728293031323334353637spring: application: name: spring-cloud-gateway jackson: property-naming-strategy: CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 cloud: gateway: discovery: locator: enabled: true routes: - id: ais-ui uri: lb://ais-ui predicates: - Path=/ais-ui/**server: port: 10106eureka: instance: prefer-ip-address: true ip-address: $&#123;k1202.eureka.instance.ip-address:$&#123;spring.cloud.client.ip-address&#125;&#125; instance-id: $&#123;eureka.instance.ip-address&#125;:$&#123;server.port&#125; client: healthcheck: enabled: true service-url: defaultZone: $&#123;k1202.eureka.server.schema&#125;://$&#123;k1202.eureka.server.username&#125;:$&#123;k1202.eureka.server.password&#125;@$&#123;k1202.eureka.server.ip-addr&#125;:$&#123;k1202.eureka.server.port&#125;/eureka/k1202: eureka: server: schema: http username: eureka password: eureka ip-addr: localhost port: 10001 配置说明： spring.cloud.gateway.discovery.locator.enabled：是否与服务注册与发现组件进行结合，通过 serviceId 转发到具体的服务实例。默认为false，设为true便开启通过服务中心的自动根据 serviceId 创建路由的功能。 spring.cloud.gateway.routes用于配合具体的路由规则，是一个数组。id可以填写注册到eureka注册中心的服务名称。 网关服务监听 10000 端口 指定注册中心的地址，以便使用服务发现功能]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Github Page+Hexo轻松搭建个人博客]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%94%A8Github%20Page%2BHexo%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建博客环境准备​ 1.安装Git。链接地址：https://git-scm.com/downloads ​ 2.安装Node.js。链接地址：https://nodejs.org/en/ ​ 3.安装Hexo，在命令行（即Git Bash）运行以下命令： 1npm install hexo-cli -g ​ 4.初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： ​ 以下，即存放Hexo初始化文件的路径， 即站点目录。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 路径为&lt;folder&gt;\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 路径为&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml ​ 5.启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server ​ 6.浏览器访问网址： http://localhost:4000/ 至此，您的Hexo博客已经搭建在本地。 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12cd /f/Workspaces/hexo/ #进入博客所在目录git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 配置SSH key配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下： 1.看看是否存在SSH密钥(keys)首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行: 用git bash执行如下命令： 1cd ~/.ssh #检查本机已存在的ssh密钥 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。 2.创建一对新的SSH密钥(keys)1234ssh-keygen -t rsa -C &quot;516052955@qq.com&quot;#这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车三次，输入完成之后，屏幕会显示如下信息： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3.在GitHub账户中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 1clip &lt; ~/.ssh/id_rsa.pub 接着： 1.登陆GitHub,进入你的Account Settings. 2.选择SSH Keys 3.粘贴密钥，添加即可 4.测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： 1$ ssh -T git@github.com 5.设置用户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 12git config --global user.name &quot;ryanlijianchang&quot;//用户名 git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 上传到GitHub如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 出现问题： 1ERROR Deployer not found: git 解决： 1npm install --save hexo-deployer-git]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
